name: CI/CD Pipeline - Flight Booking System

on:
  push:
    branches: [ main, develop ]
  workflow_dispatch:
  pull_request:
    branches: [ main, develop ]

permissions:
  contents: read
  packages: write

env:
  JAVA_VERSION: '21'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  APP_DOMAIN: thainv.duckdns.org
  DEPLOY_DIR: /home/ec2-user/flight-booking-system

jobs:
  RunUnitTest:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_DB: testdb
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
        ports: ['5432:5432']
        options: >-
          --health-cmd "pg_isready -U testuser"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7-alpine
        ports: ['6379:6379']
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: 21
          distribution: corretto
      - name: Make gradlew executable
        run: chmod +x ./gradlew
      - name: Run Unit Tests
        env:
          SPRING_PROFILES_ACTIVE: test
          DB_HOST: localhost
          DB_PORT: 5432
          REDIS_HOST: localhost
          REDIS_PORT: 6379
        run: ./gradlew clean test jacocoTestCoverageVerification --no-daemon

  RunIntegrationTest:
    needs: RunUnitTest
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_DB: integrationdb
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
        ports: ['5432:5432']
        options: >-
          --health-cmd "pg_isready -U testuser"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7-alpine
        ports: ['6379:6379']
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: 21
          distribution: corretto
      - name: Make gradlew executable
        run: chmod +x ./gradlew
      - name: Run Integration Tests
        env:
          SPRING_PROFILES_ACTIVE: integration
          DB_HOST: localhost
          DB_PORT: 5432
          REDIS_HOST: localhost
          REDIS_PORT: 6379
        run: ./gradlew clean integrationTest --no-daemon

  RunSonarScan:
    needs: RunIntegrationTest
    runs-on: ubuntu-latest
    permissions: read-all
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: 21
          distribution: corretto
      - name: Make gradlew executable
        run: chmod +x ./gradlew
      - name: Cache Sonar and Gradle
        uses: actions/cache@v3
        with:
          path: |
            ~/.sonar/cache
            ~/.gradle/caches
          key: ${{ runner.os }}-ci-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
      - name: SonarQube Analysis
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: ./gradlew clean jacocoTestReport sonar --no-daemon
        continue-on-error: true

  BuildAndPushImage:
    needs: RunSonarScan
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
      image_full: ${{ steps.meta.outputs.image_full }}
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          java-version: 21
          distribution: corretto
      - name: Build jar
        run: chmod +x ./gradlew && ./gradlew bootJar -x test
      - name: Docker metadata
        id: meta
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          IMAGE_TAG="${BRANCH_NAME}-${SHORT_SHA}"
          IMAGE_NAME="${{ github.repository }}"
          IMAGE_FULL="ghcr.io/${IMAGE_NAME}:${IMAGE_TAG}"

          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "image_full=$IMAGE_FULL" >> $GITHUB_OUTPUT

          echo "Building image: ${IMAGE_FULL}"
      - name: Log in to GHCR
        run: echo "${{ secrets.GHCR_TOKEN || secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ secrets.GHCR_USERNAME || github.actor }}" --password-stdin
      - name: Build & push Docker image
        run: |
          set -e
          IMAGE_NAME="${{ steps.meta.outputs.image_name }}"
          IMAGE_TAG="${{ steps.meta.outputs.image_tag }}"
          IMAGE_FULL="${{ steps.meta.outputs.image_full }}"
          IMAGE_LATEST="ghcr.io/${IMAGE_NAME}:latest"

          echo "Building Docker image: ${IMAGE_FULL}"
          docker build -t "${IMAGE_FULL}" -t "${IMAGE_LATEST}" .

          echo "Pushing Docker images to GHCR..."
          docker push "${IMAGE_FULL}"
          docker push "${IMAGE_LATEST}"

          echo "âœ… Image pushed successfully: ${IMAGE_FULL}"

  Deploy:
    needs: BuildAndPushImage
    runs-on: ubuntu-latest
    environment: dev
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    steps:
      - uses: actions/checkout@v4

      - name: Prepare .env for server
        run: |
          cat > .env <<EOF
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          GRAFANA_USER=${{ secrets.GRAFANA_USER }}
          GRAFANA_PASS=${{ secrets.GRAFANA_PASS }}
          CERTBOT_EMAIL=${{ secrets.CERTBOT_EMAIL }}
          CERTBOT_DOMAIN=${{ secrets.CERTBOT_DOMAIN }}
          SLACK_WEBHOOK_URL=${{ secrets.SLACK_WEBHOOK_URL }}
          IMAGE_TAG=${{ needs.BuildAndPushImage.outputs.image_tag }}
          IMAGE_NAME=${{ env.IMAGE_NAME }}
          REGISTRY=${{ env.REGISTRY }}
          EOF

      - name: Prepare deployment directory on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          script: |
            mkdir -p ${{ env.DEPLOY_DIR }}
            chmod 755 ${{ env.DEPLOY_DIR }}
            rm -rf ${{ env.DEPLOY_DIR }}/*

      - name: Copy required files to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          source: "docker-compose.yml,.env,nginx/,prometheus/,loki/"
          target: ${{ env.DEPLOY_DIR }}
          overwrite: true

      - name: Ensure Docker Compose is installed
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            if ! docker compose version &> /dev/null; then
              echo "Installing Docker Compose plugin..."
              DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
              mkdir -p $DOCKER_CONFIG/cli-plugins
              curl -SL https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-linux-x86_64 \
                -o $DOCKER_CONFIG/cli-plugins/docker-compose
              chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
            fi
            docker compose version

      - name: Install Loki Docker logging plugin
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            if ! docker plugin ls | grep -q loki; then
              echo "Installing Loki logging plugin..."
              sudo docker plugin install grafana/loki-docker-driver:latest --alias loki --grant-all-permissions
            else
              echo "Loki plugin already installed:"
              docker plugin ls | grep loki
            fi

      - name: SSH - Deploy application
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          timeout: 30m
          script: |
            set -e
            cd ${{ env.DEPLOY_DIR }}
            
            # Login to GHCR
            if [ -n "${{ secrets.GHCR_TOKEN }}" ]; then
              echo "${{ secrets.GHCR_TOKEN }}" | docker login ghcr.io -u "${{ secrets.GHCR_USERNAME }}" --password-stdin
            fi
            
            # Pull new image
            docker compose pull app
            
            # Deploy and WAIT for it to be healthy
            # This --wait flag uses the healthcheck from docker-compose.yml
            # and replaces the custom 'for' loop
            echo "Deploying and waiting for application to be healthy..."
            docker compose up -d --build app --wait
            
            echo "Application is healthy!"
            
            # Restart supporting services
            docker compose restart nginx
            docker restart flight-booking-prometheus 2>/dev/null || true
            docker restart flight-booking-alertmanager 2>/dev/null || true
            
            # Cleanup old images
            docker image prune -f

      - name: Health check endpoint
        run: |
          echo "Performing health check..."
          sleep 5
          
          if curl -fsS --max-time 10 https://${{ env.APP_DOMAIN }}/actuator/health; then
            echo "HTTPS health check passed"
          elif curl -fsS --max-time 10 http://${{ secrets.EC2_HOST }}:8080/actuator/health; then
            echo "HTTP health check passed"
          else
            echo "Health check failed!"
            exit 1
          fi

      - name: Notify Slack - Success
        if: success()
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": ":white_check_mark: Deployment successful",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": ":white_check_mark: *Deployment Successful*\n*Branch:* ${{ github.ref_name }}\n*Commit:* ${{ github.sha }}\n*Environment:* `${{ secrets.EC2_HOST }}`"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify Slack - Failure
        if: failure()
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": ":x: Deployment failed",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": ":x: *Deployment Failed*\n*Branch:* ${{ github.ref_name }}\n*Commit:* ${{ github.sha }}\n*Environment:* `${{ secrets.EC2_HOST }}`\n*Action:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Logs>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}